---
title: Part5. 함수형 프로그래밍과 자바 진화의 미래
weight: 6
---

# 함수형 프로그래밍과 자바 진화의 미래

### 18장 함수형 광점으로 생각하기

**18.1 시스템 구현과 유지보수**
 
18.1.1 공유된 가변 데이터
```
- 여러 클래스에서 공유하는 가변 데이터는 어느 클래스가 소유자인지 구분하기 어렵다.
- 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 Side-Effect Free 메서드라고 한다.
- 불변 객체를 통해서 부작용을 없앴 수 있다.
```

18.1.2 선언형 프로그래밍
```
- 어떻게에 집중하는 방식은 명령형 프로그래밍으로 고전적인 객체지향 프로그래밍이에서 이용하는 방식
- 무엇을에 집중하는 방식은 선언형 프로그래밍으로 구현 방법은 질의문을 내부 반복으로 수행한다. 
- 선언형 프로그래밍은 질의문 자체로 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.
```

18.1.3 왜 함수형 프로그래밍인가?
```
- 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다. 
```

**18.2 함수형 프로그래밍이란 무엇인가?**

> 함수를 이용하는 프로그래밍으로 함수의 의미는 수학적인 함수와 같다. 0개 이상의 인수를 가지며 한개 이상의 결과를 반환하지만 부작용(side-effect)이 없어야 한다.

> 시스템의 다른 부분의 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능을 사용하는 방식을 함수형 프로그래밍이라 한다.

18.2.1 함수형 자바
```
실질적으로 자바는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.
1. 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다.
2. 모든 객체는 불변 객체여야 한다.
3. 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
4. 수학정 함수는 주어진 인수에 하나의 값을 반환한다.
5. 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다.
```
18.2.2 참조 투명성

```
- `부작용은 감춰야한다` 라는 제약은 참조 투명성 (referential transparency) 개념으로 귀결된다.
- 같은 인수이면 같은 결과값을 반환해야 한다.
- List 같은 경우 같은 두번의 호출로 같은 요소를 포함하지만 메모리 공간은 다른 곳에 생성된다. 불변의 순수 값을 사용할 것이라면 참조적으로 투명한 것으로 간주 한다.
```

18.2.3 객체지향 프로그래밍과 함수형 프로그래밍

```
자바는 익스트림 객체지향 방식과 함수형 방식을 모두 취한다.
```

**18.3 재귀와 반복**
> 순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 사용하지 않는다.

팩토리얼 예제

```java
static int factorialIterative(int n) {
    int r = 1;
    for (int i = 1; i <= n; i++) {
        r *= i;
    }
    return r;
}

static long factorialRecusive(long n) {
    return n == 1 ? 1 : n * factorialRecusive(n-1);
}

static long factorialSteames(long n) {
    return LongSteream.rangeClosed(1, n)
                      .reduce(1,(long a, long b) -> a * b);
}
```

꼬리 재귀 팩토리얼

```java
static long factorialTailRecusive(long n) {
    return factorialHelper(1,n);
}

static long fcatorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n , n -1);
}
```

중간 값을 각자의 스택 프레임으로 저장해야하는 일반 재귀와 달리 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 있으나 자바에서는 지원하지 않는다.(스칼라 그루비 같은 jvm 언어는 이와 같은 재귀 반복을 최적화 한다.)


> - 공유 가변 자료구조를 줄이는 것은 장기적으로 프로그램 유지보수하고 디버깅하는 데 도움이 된다.  
> - 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.
> - 함수형 메서드는 입력 인수와 출력 결과만을 갖는다.
> - 같은 인수 값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. while 루프 같은 반복움능 재귀로 대체할 수 있다.
> - 자바에서는 고전 방식의 재귀보다 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.

### 19 함수형 프로그래밍 기법

19.1 함수는 모든 곳에 존재한다.
19.1.1 고차원 함수
```
Comparator.comparing 정적메소드과 같이 다음과 같은 기능을 하나이상하는 함수를 고차원함수라고 한다.
- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환
```
함수를 인수로 전달결과 반환 지역변수로 할당 구조체로 삽입할 수 있으므로 자바의 함수도 고차원 함수라고 할수 있다.
고차원 함수를 사용할 때 함수에서 어떤 언지가 사용되고 예상 못한 결과가 발생할 수 있다.
고차원 함수 구현시 사이드 이팩트를 고려해야 한다.

19.1.2 커링 (Currying)
```
Currying은 여러 개의 인자를 가진 함수를 호출 할 경우, 파라미터의 수보다 적은 수의 파라미터를 인자로 받으면 누락된 파라미터를 인자로 받는 기법을 말한다.
부분적으로 적용된 함수를 체인으로 계속 생성해 결과적으로 값을 처리하도록 하는 것이 그 본질이다.
```

19.2 영속 자료구조
19.2.1 파과적인 갱신과 함수형




